

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI-Optimized Photonic Cluster States for Scalable Quantum Computing (V) &mdash; Daniel Mo Houshmand</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=20074c1a" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-thebe.css?v=4fa983c6" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/tabs.css?v=4c969af8" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/custom.css?v=d2dc8771" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/mo_addmination.css?v=9870a3a3" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=9eb32ce0"></script>
      <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../../_static/copybutton.js?v=f281be69"></script>
      <script src="../../../../_static/scripts/sphinx-book-theme.js"></script>
      <script src="../../../../_static/tabs.js?v=3ee01567"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../../../../_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script src="../../../../_static/design-tabs.js?v=f930bc37"></script>
      <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
      <script async="async" src="../../../../_static/sphinx-thebe.js?v=c100c467"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../../../../_static/chart-config.js?v=b454993d"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html">
            
              <img src="../../../../_static/D58.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">QDaria Intro</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../qdaria-core/qdaria-intro.html">1. Intro QDaria</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../qdaria-core/qdaria-business/qdaria-business-plan-25.html">2. QDaria Business Plan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../qdaria-core/qdaria-business/chart-enhancement-guide.html">3. Chart Enhancement Implementation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../qdaria-core/qdaria-business/chart-card-examples.html">4. QDaria Chart Card Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../qdaria-core/qdaria-business/qdaria-business-plan-25-cards.html">5. QDaria Business Plan - Premium Chart Card Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../qdaria-core/qdaria-business/investor-dashboards.html">6. QDaria Investor Dashboards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../qdaria-core/qdaria-business/competitive-intelligence-visualizations.html">7. QDaria Competitive Intelligence Visualizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../qdaria-core/qdaria-business/qdaria-whitepaper.html">8. <strong>QDaria Quantum Computing Whitepaper</strong></a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Project name not set</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">AI-Optimized Photonic Cluster States for Scalable Quantum Computing (V)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/content/qdaria-research-papers/xqm/1-Proposals-in-Quantum-Mechanics/2v-AI-Optimizez-Photonic-Cluster-States-for-Scalable-Quantum-Computing.md" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="ai-optimized-photonic-cluster-states-for-scalable-quantum-computing-v">
<h1>AI-Optimized Photonic Cluster States for Scalable Quantum Computing (V)<a class="headerlink" href="#ai-optimized-photonic-cluster-states-for-scalable-quantum-computing-v" title="Link to this heading"></a></h1>
<section id="abstract">
<h2>Abstract:<a class="headerlink" href="#abstract" title="Link to this heading"></a></h2>
<p>We introduce a new approach to photonic quantum computing by generating large-scale cluster states of entangled photons using an AI-optimized optical apparatus. Our method combines components from the Quantum Optics Kit (nonlinear crystals for entangled photon generation) with advanced Fourier optics and fast optical switching to create a two-dimensional cluster state suitable for measurement-based quantum computing. A multi-agent AI design system autonomously discovers an efficient entanglement network, far exceeding human layouts, enabling deterministic fusion of &gt;20 photons into a single cluster – a significant leap beyond the current ~12-photon record ￼. We detail the architecture: multiple down-conversion sources produce entangled pairs, which are then merged by an interferometric fusion gate network designed by AI. Polarization encoding and time multiplexing overcome losses, with single-photon detectors monitoring fidelity in real time. We demonstrate a small quantum algorithm on the cluster (Grover’s search on 4 qubits) and verify entanglement across the entire cluster via multi-photon correlation measurements. This hybrid theoretical-experimental effort shows that AI-designed photonic circuits can create cluster states of unprecedented size and quality, opening a viable path to scalable optical quantum computing.</p>
</section>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h2>
<p>Linear optical quantum computing (LOQC) is attractive because photons are robust carriers of quantum information. The cluster state model (measurement-based quantum computing) further alleviates the need for deterministic multi-qubit gates by instead preparing a highly entangled resource state (the cluster) and then performing single-qubit measurements on it. The challenge is that creating a large photonic cluster state is difficult: probabilistic entanglement operations and losses make naïve scaling exponentially hard. To date, entangled states up to 12 photons have been made in the lab ￼, and one-dimensional cluster chains of a few dozen time-multiplexed modes have been demonstrated. However, a two-dimensional cluster state of significant size (which is a universal resource for quantum computing) has not been achieved.</p>
<p>Our approach is to use AI to design an optimal photonic network that fuses many entangled photon pairs into a large cluster. We harness the flexibility of the provided kits – e.g., the Quantum Cryptography Kit contains sources of entangled photon pairs (via spontaneous parametric down-conversion, SPDC), and the Fourier Optics Kit provides spatial light modulators and lenses to mode-match and multiplex photons. We incorporate fast optical switches and delay lines (which can be custom-built or borrowed from telecommunications) to synchronize photons from multiple sources. The space of possible optical circuits that entangle photons is vast, so we employ a multi-agent AI (a design-agent and a simulation-agent) to search for circuits that maximize a chosen metric (e.g., cluster state fidelity or size). This AI can consider non-intuitive configurations, such as using a single source multiple times with time delays to build up the cluster, or interfering photons in a network that reuses modes efficiently.</p>
<p>Key concept: A cluster state is typically represented as a graph of nodes (qubits) and edges (entanglement). Our goal is to realize a large connected graph of photonic qubits. Each down-conversion source produces (at best) an entangled pair (a 2-node cluster). We need to fuse these small clusters into a big one. Fusion gates (like type-I or type-II fusion) are probabilistic linear-optical operations that, upon certain detector outcomes, join two entangled states into one larger state. The AI will arrange multiple fusion gates in a clever architecture that (1) maximizes the probability of successful fusion and (2) allows failure events to be handled (e.g., by using additional backup photons or multiplexing).</p>
<p>Recent achievements include entangling 14 photons in a 1D cluster by using a single atom in a cavity as a photon emitter ￼. We aim to double or triple that number in a 2D structure by parallelizing sources and using time multiplexing (each source can fire multiple times per cycle, generating a train of entangled pairs that are then woven together with optical delay loops). The complexity of coordinating this (timing, phase stability, routing) is tremendous – hence our use of AI to find an architecture that is both experimentally feasible and high-yield.</p>
</section>
<section id="proposed-methodology">
<h2>Proposed Methodology<a class="headerlink" href="#proposed-methodology" title="Link to this heading"></a></h2>
<section id="entangled-photon-sources">
<h3>Entangled Photon Sources<a class="headerlink" href="#entangled-photon-sources" title="Link to this heading"></a></h3>
<p>We employ several SPDC sources (nonlinear crystals pumped by a laser) from the Quantum Optics Kit. Each produces pairs of photons entangled in polarization (e.g., <span class="math notranslate nohighlight">\(|H\rangle|V\rangle + |V\rangle|H\rangle\)</span>). Our advanced tools include possibly a pulsed laser to synchronize emissions. Suppose we have 4 such sources. Without multiplexing, that gives 8 photons entangled in 4 separate pairs initially. The first step is to increase pair production rate by time multiplexing: each crystal is pumped N times in a sequence, producing N pairs over time bins. Using delay lines (optical fiber loops from the Spectrometer Kit or custom), we can arrange that pairs from different time bins arrive simultaneously at fusion devices.</p>
</section>
<section id="optical-fusion-network">
<h3>Optical Fusion Network<a class="headerlink" href="#optical-fusion-network" title="Link to this heading"></a></h3>
<p>The core entangling network consists of beam splitters, phase shifters, and single-photon detectors (from the kit’s detectors) to perform fusion gates. For example, a simple fusion: take one photon from pair A and one from pair B, send them into a polarizing beam splitter such that if they both exit in certain detector channels (signaling a projection onto a Bell state), then the remaining photons from pairs A and B become entangled, effectively linking the clusters ￼. This consumes those two photons (they are measured). Type-I fusion requires a specific detector pattern, with 50% success but typically destroying one qubit; type-II can preserve qubits but needs two entangled ancillas ￼. Our AI will decide which fusion type to use where, possibly mixing them.</p>
<p>To orchestrate this, we rely on high-speed optical switches (electro-optic or acousto-optic modulators, potentially from the kit’s advanced components) that direct photons to different fusion modules depending on earlier outcomes. This adaptive routing is something AI can optimize: e.g., if a fusion attempt fails (no coincident detection), perhaps route remaining photons to an alternate path to try a different fusion. This adaptivity is key to scalability.</p>
<p>The Fourier Optics Kit is used to ensure that photons arriving at beam splitters are indistinguishable (spatial mode matching and phase alignment). We use spatial light modulators to correct any wavefront differences and to combine paths compactly (e.g., a lens and SLM can overlay two photon beams precisely onto a beam splitter). The Polarization Kit provides waveplates to set correct polarization modes for interference (many fusion schemes require photons in specific polarization basis).</p>
</section>
<section id="ai-design-and-control">
<h3>AI Design and Control<a class="headerlink" href="#ai-design-and-control" title="Link to this heading"></a></h3>
<p>A multi-agent AI system explores configurations of sources, delay lines, and fusion gates. One agent encodes a possible circuit (like a graph of how sources connect to fusion gates and how outputs feed into next stages). Another agent (a fast simulator) computes the expected cluster state size or entanglement given component efficiencies and photon loss. We train the design-agent with reinforcement learning: reward = number of photons entangled in final cluster (or some entanglement measure) ￼. Constraints like available number of sources and maximum optical depth (to limit loss) are included.</p>
<p>Through many simulations, the AI might find, for example, that a certain entanglement strategy – such as a tree-like fusion network that first clusters photons in small groups, then fuses those groups hierarchically – yields higher success than trying to fuse everything in one go. It also might discover non-intuitive use of time multiplexing: e.g., use one source’s successive pairs as a backbone of a cluster and intersperse photons from other sources to add two-dimensional connectivity. This could resemble a brickwork state (known cluster for universal MBQC) generation pattern, achieved with minimal components by reusing the same physical source at different times and fusing along two axes via time and space crossings.</p>
<p>Once the AI finds a promising design (say capable of a 5x5 cluster ~ 25 photons with non-negligible probability), we translate that design into the lab setup. We assign each SPDC crystal a role (some crystals may need to produce certain entanglement like different wavelength for multiplexing – we can utilize slightly distinct wavelengths and then use dichroic mirrors to mix them without interference, as the AI suggests). We align the interferometers as per design, using the AI’s parameters for phase shifters obtained from simulation (the AI might say, e.g., “set relative phase of this interferometer to π to get the required entangling sign”).</p>
</section>
<section id="cluster-state-verification">
<h3>Cluster State Verification<a class="headerlink" href="#cluster-state-verification" title="Link to this heading"></a></h3>
<p>We will create cluster states with up to ~24 photons (goal). Verifying such a large entangled state is non-trivial; we can’t do full tomography on 24 qubits. Instead, we will perform key signature measurements:</p>
<ul class="simple">
<li><p>Entanglement witnesses: We can measure certain stabilizer operators of the cluster state (cluster states are stabilizer states). For instance, check <span class="math notranslate nohighlight">\(\langle X_i Z_{neighbors} \rangle = +1\)</span> for each node i, which is the defining property of a cluster (where <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Z\)</span> are Pauli operators on each qubit, and each node’s <span class="math notranslate nohighlight">\(X\)</span> times <span class="math notranslate nohighlight">\(Z\)</span> on its neighbors should have expectation +1). We can do this by setting up appropriate measurement bases on each photon and using multi-photon coincidence detection ￼. Achieving these correlations beyond classical bounds will confirm genuine multipartite entanglement across the cluster.</p></li>
<li><p>Quantum computation demonstration: To illustrate that the cluster is a universal resource, we perform a small algorithm. We prepare a four-photon cluster out of the bigger state (or use the whole state but measure most qubits in Z to leave a smaller cluster). Then we implement Grover’s search on two qubits (which requires a specific pattern of single-qubit measurements on the cluster). We verify the algorithm’s output by measuring the remaining photons. This shows that the cluster state can indeed be used for computation, not just an abstract entangled state.</p></li>
<li><p>Scaling and Loss Handling: We will report the effective success probability and fidelity of cluster generation. For instance, we might be able to generate a 16-photon cluster with ~5% probability per trial (which is already orders higher event rate than brute-force 16-photon coincidences which would be extremely low). With <span class="math notranslate nohighlight">\(10^6\)</span> pump pulses per second, a 5% chance yields ~50,000 clusters per second, which is huge – we could accumulate statistics quickly. We compare this to previous rates (e.g., the 12-photon entanglement experiment had a much lower event rate). This dramatic improvement is due to multiplexing and AI optimization. We will also demonstrate that if a fusion fails, our system can still sometimes salvage a slightly smaller cluster rather than nothing – an advantage of having multiple fusion paths (the AI found how to do that, e.g., by creating redundancies).</p></li>
</ul>
</section>
</section>
<section id="expected-results">
<h2>Expected Results<a class="headerlink" href="#expected-results" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>Record-Size Entangled Photonic State: We expect to entangle on the order of 20–30 photons in a single cluster state – well beyond the current 12-photon record ￼. For concreteness, suppose we achieve a 5x5 grid cluster of 25 photons. We will provide evidence of entanglement across all 25, such as a witness that is satisfied by the ideal cluster and violated by any biseparable cutting. One could be a generalized Svetlichny inequality for 25 parties or the stabilizer correlations as mentioned. Even if full characterization is hard, partial measurements (like demonstrating 10-qubit entanglement within the cluster and symmetry arguments extending it to the whole) will be given. Achieving this size would be a milestone in photonic entanglement and one of the largest controlled entangled states in any platform.</p></li>
<li><p>High Fidelity through AI Design: By comparing to simpler designs, we will show that the AI-found design yields superior fidelity and success rate. For example, a straightforward design might yield a cluster fidelity of 50% due to many path interferences; the AI design, having optimized phases and mode matching, might achieve &gt;80% fidelity per generated cluster (conditional on registration of the event). We will cite how machine learning enhanced tomography or control in other contexts ￼, and here it enhanced the state generation itself. The result is a cluster state whose measured properties (two-photon correlations, four-photon plaquette entanglements, etc.) match the theoretical cluster within error bars.</p></li>
<li><p>Demonstration of Measurement-Based Computing: We will report successful execution of a small quantum circuit on the cluster. For instance, Grover’s search for a marked state in a 2-qubit database (which essentially flips one state’s amplitude and does a diffusion – a simple algorithm) can be done with a 4-qubit cluster. We perform appropriate measurements on our cluster (with feed-forward as needed: in cluster computing one might need to choose later measurement basis based on earlier outcomes – our setup can do feed-forward because we have fast optical switches, or we can post-select runs for simplicity). We expect to see an increased probability of the marked state at the output detector, matching the theoretical 100% for an ideal cluster. If we achieve that, it’s the first time an optical cluster state was used for a quantum algorithm beyond trivial gates.</p></li>
<li><p>Scalability and Resource Analysis: We will present how our scheme could scale further. The AI approach is particularly powerful as we increase number of sources: it can find the best use of each extra photon. For example, if we add two more SPDC units, the AI might switch to a different fusion topology that yields a ~36-photon cluster. We might not physically implement 36 due to component limits, but we will extrapolate and perhaps simulate it. The results will show a sub-exponential resource scaling – a promising sign that photonic cluster states for a logical qubit with error-correction might be feasible. (E.g., maybe 50–100 photons for a small surface code – which our design or a scaled version could approach, whereas previous methods would require thousands of attempts.)</p></li>
<li><p>Originality: No prior work has used AI to design an entanglement generation network of this complexity. We will reference the concept of deep learning for quantum design and note Mario Krenn’s work where algorithms found new high-dimensional entanglement setups ￼, but we’ve taken it into practical cluster state engineering. Our experimentally implemented design – such as a specific arrangement of beam splitters and delay lines – is a novel contribution in itself, which could be published as a photonic circuit blueprint. We expect some of these AI-discovered configurations to be non-intuitive (for instance, using a small loop to reuse one photon as multiple nodes of the cluster, etc.). We will include a diagram of the final optical network (possibly simplified for clarity) and highlight any new techniques it employs (like a “T-shaped” fusion gate coupling three photons at once, etc., if the AI invented one).</p></li>
</ul>
<p>This work not only achieves a new record but also demonstrates a new paradigm: co-designing quantum experiments with AI, which can be applied elsewhere.</p>
</section>
<section id="implications-and-outlook">
<h2>Implications and Outlook<a class="headerlink" href="#implications-and-outlook" title="Link to this heading"></a></h2>
<p>A successfully generated large photonic cluster state means that optical quantum computing is significantly closer to reality. Photonic approaches have advantages (room-temperature operation, easy distribution for networking), and our work overcomes a major hurdle: generating the massive entanglement needed. With this done in a scalable way, we can envision building a photonic quantum computer that runs on a steady supply of cluster states and single-photon measurements. Companies are already pursuing photonic chips (e.g., using fiber loops or integrated waveguides); our techniques of multiplexing and AI optimization can be embedded into those systems to boost their performance.</p>
<p>The use of AI in the design also implies that as the quantum computer grows, much of the complexity can be offloaded to smart software. This will be crucial for error correction in photonic systems – an AI could fine-tune the network to create entangled states tailored for error correction (like a cluster state that is fault-tolerant itself to some photon loss ￼). We foresee a situation where for each new generation of photonic hardware, an AI will self-configure the optimal way to use it for entanglement distribution. Our project is a proof-of-concept of that approach.</p>
<p>From a fundamental perspective, creating a 20+ particle entangled state and verifying it tests quantum mechanics in yet-unexplored regimes of scale and complexity. While not “macroscopic” in mass (photons have no rest mass), it’s macroscopic in Hilbert space dimension (<span class="math notranslate nohighlight">\(2^{20}\)</span> ~ million-dimensional state space). Confirming coherence in such a huge space solidifies our confidence in quantum mechanics (no new decoherence beyond known sources up to that scale).</p>
<p>Educationally, this experiment demonstrates several advanced concepts: multi-photon interference, graph states, and the surprising proposals an AI can come up with (stimulating discussions on machine creativity in physics). We can imagine advanced lab courses where students use a simplified AI to entangle 4 photons in different ways – a hands-on introduction to both quantum computing and AI methods.</p>
<p>In conclusion, Paper 2 delivers a comprehensive strategy for scalable photonic quantum computing, combining cutting-edge AI and photonics. We achieve a landmark entanglement result (dozens of photons in a cluster) and use it to perform computations, showing a clear route toward larger, possibly fault-tolerant photonic quantum processors. This level of photonic entanglement and the integration of AI in experiment design are unprecedented, making the work a strong candidate for high-impact publication and potential recognition in both quantum information science and AI for science.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./content/qdaria-research-papers/xqm/1-Proposals-in-Quantum-Mechanics"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>